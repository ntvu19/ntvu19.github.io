<!doctype html>
<html lang="vi-VN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Câu hỏi phỏng vấn Cấu Trúc Dữ Liệu - Vu T. Nguyen</title><link rel="icon" href="/icon/main/icon.png"><meta name="description" content="">
    <link rel="preload" href="/assets/style-DboSCkd9.css" as="style"><link rel="stylesheet" href="/assets/style-DboSCkd9.css">
    <link rel="modulepreload" href="/assets/app-DFqNa0KN.js"><link rel="modulepreload" href="/assets/index.html-BH2dD0S2.js">
    <link rel="prefetch" href="/assets/index.html-Drlf0YkZ.js" as="script"><link rel="prefetch" href="/assets/index.html-UnNGdrav.js" as="script"><link rel="prefetch" href="/assets/index.html-Bux7AIoR.js" as="script"><link rel="prefetch" href="/assets/index.html-BXRq1v5Y.js" as="script"><link rel="prefetch" href="/assets/index.html-CO-aezyF.js" as="script"><link rel="prefetch" href="/assets/index.html-C8bsb8xC.js" as="script"><link rel="prefetch" href="/assets/index.html-BjxyPvav.js" as="script"><link rel="prefetch" href="/assets/index.html-ChtxAz4e.js" as="script"><link rel="prefetch" href="/assets/index.html-BlTIrcOt.js" as="script"><link rel="prefetch" href="/assets/index.html-R15Ksbkv.js" as="script"><link rel="prefetch" href="/assets/index.html-B2qH5dcn.js" as="script"><link rel="prefetch" href="/assets/01-modern-os-design-and-management.html-C9g2o1hC.js" as="script"><link rel="prefetch" href="/assets/02-os-performance-optimization-in-multiuser-and-multiprocessing-environments.html-BlrtK7EE.js" as="script"><link rel="prefetch" href="/assets/03-protection-and-security-mechanisms-in-os-design.html-BwpnZGE4.js" as="script"><link rel="prefetch" href="/assets/04-resource-management-in-os.html-BZdyVdjW.js" as="script"><link rel="prefetch" href="/assets/05-the-evolution-of-os-in-the-context-of-cloud-computing-and-embedded-systems.html-DgzJ1NpV.js" as="script"><link rel="prefetch" href="/assets/06-process-synchronization-and-ipc.html-BV8GQCaB.js" as="script"><link rel="prefetch" href="/assets/07-storage-systems-in-os.html-Cad2XKIb.js" as="script"><link rel="prefetch" href="/assets/01-process-management-model-in-modern-operating-system.html-oc_noOCR.js" as="script"><link rel="prefetch" href="/assets/02-ipc-mechanisms-comparison.html-CmBw2mXy.js" as="script"><link rel="prefetch" href="/assets/03-multi-processing-in-multi-kernel-operating-system.html-C65ajuYf.js" as="script"><link rel="prefetch" href="/assets/04-cpu-scheduler-in-multi-process-environment.html-BRFZaiWQ.js" as="script"><link rel="prefetch" href="/assets/05-survey-and-analyze-the-process-creation-and-management-techniques-in-unix-and-windows.html-CCEhLVgG.js" as="script"><link rel="prefetch" href="/assets/06-process-management-in-mobile-operating-system-ios-and-android.html-BV50XIyH.js" as="script"><link rel="prefetch" href="/assets/07-data-structure-and-process-support-mechanisms-in-the-linux-kernel.html-CB7zXLNB.js" as="script"><link rel="prefetch" href="/assets/08-performance-optimization-through-context-switching-management.html-CCIv1a9e.js" as="script"><link rel="prefetch" href="/assets/hacking-the-art-of-exploitation-2nd-erickson.html-DdeCG_Pt.js" as="script"><link rel="prefetch" href="/assets/index.html-Ov-ua3ko.js" as="script"><link rel="prefetch" href="/assets/build-your-own-x.html-DEzWB9P5.js" as="script"><link rel="prefetch" href="/assets/index.html-BFwZ3lW-.js" as="script"><link rel="prefetch" href="/assets/project-based-learning.html-tiuYuZLH.js" as="script"><link rel="prefetch" href="/assets/observer-pattern.html-YqEbX7s2.js" as="script"><link rel="prefetch" href="/assets/strategy-pattern.html-CqXdPVGF.js" as="script"><link rel="prefetch" href="/assets/index.html-C3i-WD93.js" as="script"><link rel="prefetch" href="/assets/index.html-BRbwgv8K.js" as="script"><link rel="prefetch" href="/assets/index.html-B40nsOSP.js" as="script"><link rel="prefetch" href="/assets/index.html-tUqjKt-I.js" as="script"><link rel="prefetch" href="/assets/index.html-CYbJFXEs.js" as="script"><link rel="prefetch" href="/assets/index.html-BpiR2UYY.js" as="script"><link rel="prefetch" href="/assets/index.html-u2wBx7vL.js" as="script"><link rel="prefetch" href="/assets/index.html-ekQWhcR2.js" as="script"><link rel="prefetch" href="/assets/index.html-CG-2Fdql.js" as="script"><link rel="prefetch" href="/assets/index.html-BrdQM949.js" as="script"><link rel="prefetch" href="/assets/index.html-k3swOFG3.js" as="script"><link rel="prefetch" href="/assets/index.html-DgBpsQ29.js" as="script"><link rel="prefetch" href="/assets/index.html-hb6PUKYt.js" as="script"><link rel="prefetch" href="/assets/index.html-NiNZ1-aW.js" as="script"><link rel="prefetch" href="/assets/index.html-_o2-Z3i9.js" as="script"><link rel="prefetch" href="/assets/index.html-Bo7sFm1D.js" as="script"><link rel="prefetch" href="/assets/index.html-BGaq7i2m.js" as="script"><link rel="prefetch" href="/assets/index.html-qLna3Wl8.js" as="script"><link rel="prefetch" href="/assets/index.html-DFcY3R3-.js" as="script"><link rel="prefetch" href="/assets/index.html-CeUm0b58.js" as="script"><link rel="prefetch" href="/assets/index.html-Wui1tvuj.js" as="script"><link rel="prefetch" href="/assets/index.html-XYiiby8b.js" as="script"><link rel="prefetch" href="/assets/index.html-CavkIV2f.js" as="script"><link rel="prefetch" href="/assets/index.html-VebTNDGQ.js" as="script"><link rel="prefetch" href="/assets/index.html-DIAfcFXt.js" as="script"><link rel="prefetch" href="/assets/index.html-zj7oQv4O.js" as="script"><link rel="prefetch" href="/assets/index.html-CQUq3y7F.js" as="script"><link rel="prefetch" href="/assets/index.html-DQ18QZl6.js" as="script"><link rel="prefetch" href="/assets/index.html-Bt1HzGq1.js" as="script"><link rel="prefetch" href="/assets/index.html-5I1Zj2ZD.js" as="script"><link rel="prefetch" href="/assets/index.html-DmBJGZCP.js" as="script"><link rel="prefetch" href="/assets/index.html-DK3949Z_.js" as="script"><link rel="prefetch" href="/assets/index.html-D6gTxEuK.js" as="script"><link rel="prefetch" href="/assets/index.html-DuByE_cq.js" as="script"><link rel="prefetch" href="/assets/index.html-9xSg7Y9w.js" as="script"><link rel="prefetch" href="/assets/index.html-CsEuVgiz.js" as="script"><link rel="prefetch" href="/assets/index.html-Bhx7lfLe.js" as="script"><link rel="prefetch" href="/assets/index.html-DnjcA9XB.js" as="script"><link rel="prefetch" href="/assets/index.html-DePKIT-p.js" as="script"><link rel="prefetch" href="/assets/index.html-DOISftvK.js" as="script"><link rel="prefetch" href="/assets/index.html-DzUUAFpE.js" as="script"><link rel="prefetch" href="/assets/index.html-BW_QbkHN.js" as="script"><link rel="prefetch" href="/assets/index.html-DRbBm5oZ.js" as="script"><link rel="prefetch" href="/assets/index.html-Bq00w4eN.js" as="script"><link rel="prefetch" href="/assets/index.html-CnlbjvgE.js" as="script"><link rel="prefetch" href="/assets/index.html-CFo6U--m.js" as="script"><link rel="prefetch" href="/assets/index.html-CGU833ks.js" as="script"><link rel="prefetch" href="/assets/404.html-dBzuvSUA.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-QXEOFQJV-Dq9X6NB1.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!----><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/vi/"><!----><!----></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Khác"><span class="title">Khác</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Khác"><span class="title">Khác</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vi/others/books/" aria-label="Tài liệu"><!--[--><!--[--><!--]--><!--]-->Tài liệu<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/vi/others/references/" aria-label="Tham khảo"><!--[--><!--[--><!--]--><!--]-->Tham khảo<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Việt Nam</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Việt Nam</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/" aria-label="English"><!--[--><!--[--><!--]--><!--]-->English<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/vi/others/references/ren0503-fullstack-interviews/basics/data-structures/" aria-label="Việt Nam"><!--[--><!--[--><!--]--><!--]-->Việt Nam<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><!----><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Khác"><span class="title">Khác</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Khác"><span class="title">Khác</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vi/others/books/" aria-label="Tài liệu"><!--[--><!--[--><!--]--><!--]-->Tài liệu<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/vi/others/references/" aria-label="Tham khảo"><!--[--><!--[--><!--]--><!--]-->Tham khảo<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Việt Nam</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Việt Nam</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/" aria-label="English"><!--[--><!--[--><!--]--><!--]-->English<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/vi/others/references/ren0503-fullstack-interviews/basics/data-structures/" aria-label="Việt Nam"><!--[--><!--[--><!--]--><!--]-->Việt Nam<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Câu hỏi phỏng vấn Cấu Trúc Dữ Liệu <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="cau-hoi-phong-van-cau-truc-du-lieu" tabindex="-1"><a class="header-anchor" href="#cau-hoi-phong-van-cau-truc-du-lieu"><span>Câu hỏi phỏng vấn Cấu Trúc Dữ Liệu</span></a></h1><p><img src="/assets/data_structure-DauOTyPb.jpg" alt=""></p><ul><li><p>Cấu trúc dữ liệu là một khái niệm cơ bản trong bất kỳ ngôn ngữ lập trình nào, là phần thiết yếu trong thiết kế thuật toán.</p></li><li><p>Nó được sử dụng để tổ chức và chỉnh sửa dữ liệu một cách hiệu quả.</p></li><li><p>Cấu trúc dữ liệu là cách dữ liệu và các mối quan hệ của nó được biểu diễn, hỗ trợ việc áp dụng các tính năng hoặc thuật toán khác nhau hoạt động một cách tối ưu.</p></li></ul><h3 id="kieu" tabindex="-1"><a class="header-anchor" href="#kieu"><span>Kiểu</span></a></h3><p>Có hai kiểu cấu trúc dữ liệu:</p><ul><li>Cấu trúc dữ liệu tuyến tính: Nếu các phần tử của cấu trúc dữ liệu là một chuỗi tuần tự hoặc danh sách tuyến tính. Nó được gọi là cấu trúc dữ liệu tuyến tính. Ví dụ: ,mảng, danh sách liên kết, ngăn xếp, hàng đợi,...</li><li>Cấu trúc dữ liệu phi tuyến tính: Nếu các phần tử của cấu trúc dữ liệu tạo ra cách duyệt qua các phần tử không theo thứ tự, thì nó là cấu trúc dữ liệu phi tuyến tính. Ví dụ: Cây, đồ thị,...</li></ul><p><img src="/assets/data-structure-types-D3iH427u.png" alt="type"></p><h3 id="ung-dung" tabindex="-1"><a class="header-anchor" href="#ung-dung"><span>Ứng dụng</span></a></h3><p>Cấu trúc dữ liệu là nền tảng cốt lõi của lập trình phần mềm vì để bất kỳ thuật toán cho một vấn đề nhất định nào hoạt động hiệu quả đều phụ thuộc vào mức độ hiệu quả của dữ liệu được cấu trúc.</p><p>Các ứng dụng của cấu trúc dữ liệu:</p><ol><li>Trí thông minh nhân tạo</li><li>Thiết kế trình biên dịch</li><li>Máy học</li><li>Thiết kế và quản lý cơ sở dữ liệu</li><li>Blockchain</li><li>Tính toán và thống kê</li><li>Phát triển hệ điều hành</li><li>Xử lý hình ảnh và âm thanh</li><li>Mã hoá</li></ol><p><img src="/assets/applications-data-structure-94b_jSIk.png" alt="application"></p><h3 id="loi-ich" tabindex="-1"><a class="header-anchor" href="#loi-ich"><span>Lợi ích</span></a></h3><p>Bất kỳ vấn đề nào đều có những hạn chế về tốc độ giải quyết (thời gian) và lượng tài nguyên tiêu tốn (không gian). Một vấn đề bị hạn chế bởi độ phức tạp về không gian và thời gian phải được giải quyết một cách hiệu quả.</p><p>Để làm được điều này, vấn đề phải được biểu diễn ở một dạng cấu trúc phù hợp mà ở đó các thuật toán được áp dụng tốt nhất.</p><p>Lựa chọn cấu trúc dữ liệu thích hợp trở thành bước quan trọng nhất trước khi áp dụng thuật toán cho bất kỳ vấn đề nào.</p><blockquote><p>&quot;Có sẵn kiến thức về các loại cấu trúc dữ liệu khác nhau sẽ giúp lập trình viên lựa chọn cấu trúc dữ liệu phù hợp nhất để giải quyết vấn đề một cách hiệu quả. Nó không chỉ nằm ở việc làm giải pháp của bạn hoạt động, mà còn là giải pháp đó hoạt động hiệu quả như thế nào.&quot;</p></blockquote><h2 id="cau-hoi-phong-van-cho-fresher" tabindex="-1"><a class="header-anchor" href="#cau-hoi-phong-van-cho-fresher"><span>Câu hỏi phỏng vấn cho Fresher</span></a></h2><h3 id="_1-ban-co-the-giai-thich-su-khac-nhau-giua-cau-truc-tap-tin-va-cau-truc-luu-tru" tabindex="-1"><a class="header-anchor" href="#_1-ban-co-the-giai-thich-su-khac-nhau-giua-cau-truc-tap-tin-va-cau-truc-luu-tru"><span>1. Bạn có thể giải thích sự khác nhau giữa cấu trúc tập tin và cấu trúc lưu trữ?</span></a></h3><p>Sự khác biệt chính giữa cấu trúc tập và cấu trúc lưu trữ là dựa trên không gian bộ nhớ đang được truy cập.</p><p><strong>Cấu trúc lưu trữ:</strong> Là sự biểu diễn cấu trúc dữ liệu trong bộ nhớ máy tính.</p><p><strong>Cấu trúc tập tin:</strong> Là biểu diễn cấu trúc lưu trữ trong bộ nhớ phụ/thứ cấp.</p><h3 id="_2-ban-co-the-noi-su-khac-biet-giua-cau-truc-du-lieu-tuyen-tinh-va-phi-tuyen-tinh" tabindex="-1"><a class="header-anchor" href="#_2-ban-co-the-noi-su-khac-biet-giua-cau-truc-du-lieu-tuyen-tinh-va-phi-tuyen-tinh"><span>2. Bạn có thể nói sự khác biệt giữa cấu trúc dữ liệu tuyến tính và phi tuyến tính?</span></a></h3><p>Nếu các phần tử của cấu trúc dữ liệu là một chuỗi hay danh sách tuyến tính thì nó gọi là cấu trúc dữ liệu tuyến tính. Trong khi đó, cấu trúc dữ liệu cho duyệt các phần tử không theo thứ tự nào gọi cấu trúc dữ liệu phi tuyến tính.</p><p>Danh sách, ngăn xếp và hàng đợi là ví dụ của cấu trúc dữ liệu tuyến tính trong khi cây và đồ thị là cấu trúc dữ liệu phi tuyến tính.</p><p><img src="/assets/linear-vs-non-linear-BfwuOEQZ.png" alt="linear-vs-non-linear"></p><h3 id="_3-mang-la-gi" tabindex="-1"><a class="header-anchor" href="#_3-mang-la-gi"><span>3. Mảng là gì?</span></a></h3><p>Mảng là tập hợp các loại dữ liệu cùng <strong>kiểu</strong> được lưu trữ tại các vị trí bộ nhớ liền kề. Đây là cấu trúc dữ liệu đơn giản nhất mà phần tử dữ liệu có thể được truy cập ngẫu nhiên bằng cách sử dụng chỉ mục của nó.</p><h3 id="_4-mang-đa-chieu-la-gi" tabindex="-1"><a class="header-anchor" href="#_4-mang-đa-chieu-la-gi"><span>4. Mảng đa chiều là gì?</span></a></h3><p>Mảng đa chiều là những cấu trúc dữ liệu mảng trên nhiều chiều khác nhau.</p><p>Điều này chỉ ra rằng sẽ có nhiều hơn một chỉ mục cho mỗi điểm lưu trữ. Loại cấu trúc dữ liệu này chủ yếu được sử dụng trong trường hợp dữ liệu không thể được biểu diễn hoặc lưu trữ trên mảng một chiều. Mảng đa chiều được sử dụng phổ biến nhất là mảng hai chiều.</p><p>Mảng hai chiều mô phỏng cấu trúc dạng bảng giúp dễ dàng lưu trữ lượng lớn dữ liệu được truy cập bằng cách sử dụng con trỏ hàng và cột.</p><p><img src="/assets/multidimensional-array-CF80-tGX.png" alt="multi-array"></p><h3 id="_5-danh-sach-lien-ket-la-gi" tabindex="-1"><a class="header-anchor" href="#_5-danh-sach-lien-ket-la-gi"><span>5. Danh sách liên kết là gì?</span></a></h3><p>Danh sách liên kết là một <strong>chuỗi tuần tự các nút</strong>, trong đó các nút được liên kết với nhau thông qua con trỏ tham chiếu. Các phần tử <strong>không được lưu trữ</strong> tại các vị trí liền kề trong bộ nhớ. Chúng được liên kết bằng cách sử dụng con trỏ để tạo thành một chuỗi. Điều này tạo thành một liên kết dạng chuỗi để lưu trữ dữ liệu.</p><p>Mỗi nút thường có hai phần:</p><ul><li>Trường dữ liệu</li><li>Tham chiếu(con trỏ) đến nút kế tiếp</li></ul><p>Nút đầu tiên trong danh sách liên kết gọi là head, nút cuối cùng gọi là tail và trỏ đến null. Null trong trường tham chiếu chỉ ra nút đó là tail. Nếu danh sách trống, head sẽ là tham chiếu null.</p><p><img src="/assets/linked-list-BfxKg6iK.png" alt="linked-list"></p><h3 id="_6-danh-sach-lien-ket-la-tuyen-tinh-hay-phi-tuyen-tinh" tabindex="-1"><a class="header-anchor" href="#_6-danh-sach-lien-ket-la-tuyen-tinh-hay-phi-tuyen-tinh"><span>6. Danh sách liên kết là tuyến tính hay phi tuyến tính?</span></a></h3><p>Danh sách liên kết có thể được coi là cấu trúc dữ liệu tuyến tính và cả phi tuyến tính. Điều này phụ thuộc vào ứng dụng mà chúng được sử dụng.</p><p>Khi danh sách liên kết được sử dụng cho truy cập, nó được coi là một cấu trúc dữ liệu tuyến tính. Khi chúng được sử dụng để lưu trữ dữ liệu, nó có thể được coi là một cấu trúc dữ liệu phi tuyến tính.</p><h3 id="_7-danh-sach-lien-ket-co-hieu-qua-hon-mang" tabindex="-1"><a class="header-anchor" href="#_7-danh-sach-lien-ket-co-hieu-qua-hon-mang"><span>7. Danh sách liên kết có hiệu quả hơn mảng?</span></a></h3><ol><li><strong>Chèn và xoá</strong></li></ol><ul><li>Quá trình chèn và xoá là rất tốn kém trong mảng vì phải tạo các phần tử mới và dịch chuyển các phần tử đã có.</li><li>Nhưng trong danh sách liên kết, các thao tác này dễ dàng hơn vì chỉ cập nhật địa chỉ hiện tại trong con trỏ tiếp theo của một nút.</li></ul><ol start="2"><li><strong>Cấu trúc dữ liệu động</strong></li></ol><ul><li>Danh sách liên kết là cấu trúc dữ liệu động có nghĩa là không cần cho kích thước ban đầu khi tạo, nó có thể mở rộng hay co lại theo thời gian bởi quá trình cấp phát hay thu hồi của bộ nhớ.</li><li>Trong khi đó, kích thước của mảng là giới hạn về số lượng phần tử được lưu trong bộ nhớ chính.</li></ul><ol start="3"><li><strong>Không lãng phí bộ nhớ</strong></li></ol><ul><li><p>Vì kích thước của danh sách liên kết có thể tăng lên hoặc co lại dựa trên nhu cầu của chương trình, nên không có bộ nhớ nào bị lãng phí vì nó được cấp phát trong thời gian chạy.</p></li><li><p>Với mảng, nếu chúng ta khai báo một mảng có kích thước 10 và chỉ lưu trữ 3 phần tử trong đó, thì không gian cho 7 phần tử sẽ bị lãng phí. Do đó, khả năng lãng phí bộ nhớ trong các mảng nhiều hơn.</p></li></ul><h3 id="_8-giai-thich-truong-hop-nao-su-dung-danh-sach-lien-ket-va-truong-hop-nao-su-dung-mang" tabindex="-1"><a class="header-anchor" href="#_8-giai-thich-truong-hop-nao-su-dung-danh-sach-lien-ket-va-truong-hop-nao-su-dung-mang"><span>8. Giải thích trường hợp nào sử dụng danh sách liên kết và trường hợp nào sử dụng mảng?</span></a></h3><p>Các trường hợp sử dụng danh sách liên kết tốt hơn mảng:</p><ul><li>Khi ta không biết trước chính xác số lượng phần tử.</li><li>Khi ta biết sẽ có một lượng lớn thao tác thêm hoặc xoá.</li><li>Số lượng thao tác truy cập ngẫu nhiên là rất ít.</li><li>Khi muốn chèn các mục vào bất kỳ vị trí nào giữa danh sách, chẳng hạn như khi triển khai hàng đợi ưu tiên, danh sách liên kết sẽ phù hợp hơn.</li></ul><p>Các trường hợp dùng mảng tốt hơn danh sách liên kết:</p><ul><li>Khi cần đánh chỉ mục cho các truy cập phần tử ngẫu nhiên thường xuyên.</li><li>Khi ta biết trước số lượng phần tử mảng để cấp phát bộ nhớ.</li><li>Khi chúng ta cần tốc độ khi lặp lại các phần tử trong chuỗi.</li><li>Khi cần quan tâm bộ nhớ: <ol><li>Một mảng đầy sẽ tốn ít bộ nhớ hơn danh sách liên kết</li><li>Mỗi phần tử trong mảng chỉ biễu diễn dữ liệu trong khi mỗi nút trong danh sách liên kết phải biễu diễn thêm một hoặc nhiều con trỏ cho liên kết đến các nút khác.</li></ol></li></ul><p>Tóm lại, các yêu cầu về không gian, thời gian và mức độ dễ thực hiện được xem xét để quyết định cấu trúc dữ liệu nào sẽ được sử dụng cho mục đích gì.</p><h3 id="_9-danh-sach-lien-ket-đoi-ddl-la-gi" tabindex="-1"><a class="header-anchor" href="#_9-danh-sach-lien-ket-đoi-ddl-la-gi"><span>9. Danh sách liên kết đôi (DDL) là gì?</span></a></h3><p>Đây là một loại danh sách liên kết phức tạp, trong đó một nút có hai tham chiếu:</p><ul><li>Một tham chiếu liên kết với nút tiếp theo trong chuỗi</li><li>Một tham chiếu khác liên kết với nút trước đó.</li></ul><p>Cấu trúc này cho phép duyệt các phần tử dữ liệu theo cả hai hướng (trái sang phải và ngược lại).</p><p>Các ứng dụng của DLL là:</p><ul><li>Danh sách phát nhạc với bài hát tiếp theo và các tùy chọn điều hướng bài hát trước đó.</li><li>Bộ nhớ cache của trình duyệt với các trang đã truy cập BACK-FORWARD</li><li>Chức năng hoàn tác và phục hồi trên các nền tảng như word, paint, v.v., nơi bạn có thể nút undo để truy cập trang trước.</li></ul><h3 id="_10-ngan-xep-la-gi" tabindex="-1"><a class="header-anchor" href="#_10-ngan-xep-la-gi"><span>10. Ngăn xếp là gì</span></a></h3><p>Ngăn xếp là một cấu trúc dữ liệu tuyến tính tuân theo cách tiếp cận LIFO (Last In First Out) để truy cập các phần tử.</p><p>Các thao tác cơ bản trong ngăn xếp:</p><ul><li><em>Push</em>: thêm phần tử vào đỉnh ngăn xếp</li><li><em>Pop</em>: lấy phần tử từ đỉnh ngăn xếp</li><li><em>Peek</em>: lấy giá trị phần tử từ đỉnh ngăn xếp, mà không xóa nó khỏi ngăn xếp</li></ul><p><img src="/assets/stack-eeFF5Oas.png" alt="stack"></p><p>Các ứng dụng của ngăn xếp:</p><ul><li>Tính các biểu thức đại số</li><li>Quản lý bộ nhớ khi thực thi chương trình</li></ul><h3 id="_11-hang-đoi-la-gi" tabindex="-1"><a class="header-anchor" href="#_11-hang-đoi-la-gi"><span>11. Hàng đợi là gì</span></a></h3><p>Hàng đợi là một cấu trúc dữ liệu tuyến tính tuân theo phương pháp FIFO (First In First Out) để truy cập các phần tử.</p><p>Các thao tác cơ bản trong hàng đợi:</p><ul><li><em>enqueue</em>: thêm đối tượng vào cuối hàng đợi.</li><li><em>dequeue</em>: lấy đối tượng ở đầu ra khỏi hàng đợi và trả về giá trị của nó.</li><li><em>front</em>: trả về giá trị của phần tử nằm ở đầu hàng đợi mà không hủy nó.</li><li><em>rear</em>: trả về giá trị của phần tử nằm ở cuối hàng đợi mà không hủy nó.</li></ul><p><img src="/assets/queue-j6don1jA.png" alt="queue"></p><p>Ứng dụng của hàng đợi:</p><ul><li>Dùng trong các hệ điều hành song song</li><li>Xử lý yêu cầu trang web</li><li>Dùng làm bộ đệm cho ứng dụng nghe nhạc</li><li>Tác vụ CPU</li></ul><h3 id="_12-ngan-xep-va-hang-đoi-khac-nhau-the-nao" tabindex="-1"><a class="header-anchor" href="#_12-ngan-xep-va-hang-đoi-khac-nhau-the-nao"><span>12. Ngăn xếp và hàng đợi khác nhau thế nào?</span></a></h3><p>Trong ngăn xếp phần tử được thêm vào gần nhất sẽ được lấy ra đầu tiên, còn trong hàng đợi nó sẽ được lấy ra cuối cùng.</p><p><img src="/assets/stack-vs-queue-DP6D3mRT.png" alt="stack-queue"></p><h3 id="_13-giai-thich-quy-trinh-đang-sau-viec-luu-tru-mot-bien-trong-bo-nho" tabindex="-1"><a class="header-anchor" href="#_13-giai-thich-quy-trinh-đang-sau-viec-luu-tru-mot-bien-trong-bo-nho"><span>13. Giải thích quy trình đằng sau việc lưu trữ một biến trong bộ nhớ.</span></a></h3><p>Một biến được lưu trữ trong bộ nhớ dựa trên dung lượng bộ nhớ cần thiết. Sau đây là các bước được thực hiện để lưu trữ một biến:</p><ol><li>Đầu tiên, nó chỉ định số lượng bộ nhớ cần thiết.</li><li>Sau đó, nó được lưu trữ dựa trên cấu trúc dữ liệu đang được sử dụng. <ul><li>Sử dụng các khái niệm như cấp phát động đảm bảo hiệu quả cao và các đơn vị lưu trữ có thể được truy cập dựa trên các yêu cầu trong thời gian thực.</li></ul></li></ol><h3 id="_14-trien-khai-hang-đoi-bang-ngan-xep" tabindex="-1"><a class="header-anchor" href="#_14-trien-khai-hang-đoi-bang-ngan-xep"><span>14. Triển khai hàng đợi bằng ngăn xếp</span></a></h3><p>Một hàng đợi có thể triển khai bằng cách dùng <strong>hai ngăn xếp</strong>.</p><p>Cho hàng đợi <code>q</code> và hai ngăn xếp <code>stack1</code> và <code>stack2</code> để triển khai <code>q</code>. Ta biết ngăn xếp hỗ trợ các thao tác push, pop và peek, ta sẽ dùng các thao tác đó để mô phỏng các hoạt động của hàng đợi, enqueue và dequeue. Do đó, hàng đợi <code>q</code> có thể triển khai theo hai cách (cả hai cách đều có độ phức tạp không gian là O(n)):</p><ol><li>Cần nhiều chi phí chi enqueue</li></ol><p>Ở đây, phần tử cũ nhất luôn ở trên cùng của <code>stack1</code> đảm bảo hoạt động dequeue xảy ra với độ phức tạp thời gian O (1).</p><p>Để đặt phần tử vào đầu <code>stack1</code>, <code>stack2</code> được sử dụng.</p><p>Mã giả:</p><ul><li>Enqueue: Độ phức tạp thời gian là O(n):</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">enqueue(q, data):</span>
<span class="line">    While stack1 is not empty:</span>
<span class="line">        Push everything from stack1 to stack2.</span>
<span class="line">        Push data to stack1</span>
<span class="line">        Push everything back to stack1.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Dequeue: Độ phức tạp thời gian là O(1):</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">dequeue(q):</span>
<span class="line">    If stack1 is empty then error</span>
<span class="line">    else</span>
<span class="line">        Pop an item from stack1 and return it</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>Cần nhiều chi phí cho dequeue</li></ol><p>Ở đây, đối với thao tác enqueue, phần tử mới được đẩy lên trên cùng của <code>stack1</code>.Thế nên, độ phức tạp thời gian hoạt động của enqueue là O(1).</p><p>Với dequeue, nếu <code>stack2</code> trống, tất cả các phần tử từ <code>stack1</code> sẽ được chuyển đến <code>stack2</code> và pop phần tử trên cùng của <code>stack2</code> để lấy kết quả. Về cơ bản, đảo ngược danh sách bằng cách đẩy vào một ngăn xếp và trả về phần tử được enqueue đầu tiên. Thao tác đẩy tất cả các phần tử vào ngăn xếp mới có độ phức tạp O(n).</p><p>Mã giả:</p><ul><li>Enqueue: Độ phức tạp thời gian là O(1):</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">enqueue(q, data):</span>
<span class="line">    Push data to stack1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Dequeue: Độ phức tạp thời gian là O(n):</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">dequeue(q):</span>
<span class="line">    If both stacks are empty then raise error.</span>
<span class="line">    If stack2 is empty:</span>
<span class="line">        While stack1 is not empty:</span>
<span class="line">            push everything from stack1 to stack2.</span>
<span class="line">    Pop the element from stack2 and return it.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_15-trien-khai-ngan-xep-bang-hang-đoi" tabindex="-1"><a class="header-anchor" href="#_15-trien-khai-ngan-xep-bang-hang-đoi"><span>15. Triển khai ngăn xếp bằng hàng đợi?</span></a></h3><p>Một ngăn xếp có thể được triển khai bằng 2 hai hàng đợi. Một hàng đợi hỗ trợ các thao tác là enqueue và dequeue. Ta sẽ dùng chúng để tạo các thao tác push, pop.</p><p>Đầu tiên ta có hai hàng đợi là <code>q1</code> và <code>q2</code>. Ngăn xếp được triển khai bởi hàng đợi theo hai cách.</p><ol><li>Tốn chi phí cho push:</li></ol><p>Phương thức này đảm bảo các phần tử mới được thêm vào sẽ luôn ở đằng trước của <code>q1</code>, thế nên thao tác pop sẽ là deque từ <code>q1</code>.</p><p><code>q2</code> được dùng như một hàng đợi phụ trợ để phần tử mới vào trước <code>q1</code> trong khi đảm bảo pop xảy ra ở độ phức tạp O(1).</p><p>Mã giả:</p><ul><li>Push phần tử vào ngăn xếp: Độ phức tạp thời gian là O(n).</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">push(s, data):</span>
<span class="line">    Enqueue data to q2</span>
<span class="line">    Dequeue elements one by one from q1 and enqueue to q2.</span>
<span class="line">    Swap the names of q1 and q2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Pop phần tử khỏi ngăn xếp: Độ phức tạp thời gian là O(1).</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">pop(s):</span>
<span class="line">    dequeue from q1 and return it.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>Tốn chi phí cho pop:</li></ol><p>Trong hoạt động push, phần tử được enqueue vào hàng đợi <code>q1</code>.</p><p>Trong hoạt động pop, tất cả các phần tử từ <code>q1</code> ngoại trừ phần tử còn lại cuối cùng, được đẩy sang <code>q2</code> nếu nó trống. Phần tử cuối cùng còn lại đó của <code>q1</code> được dequeue và trả về.</p><p>Mã giả:</p><ul><li>Push phần tử vào ngăn xếp: Độ phức tạp thời gian là O(1).</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">push(s,data):</span>
<span class="line">    Enqueue data to q1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Pop phần tử khỏi ngăn xếp: Độ phức tạp thời gian là O(n).</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">pop(s):</span>
<span class="line">    Step1: Dequeue every elements except the last element from q1 and enqueue to q2.</span>
<span class="line">    Step2: Dequeue the last item of q1, the dequeued item is stored in result variable.</span>
<span class="line">    Step3: Swap the names of q1 and q2 (for getting updated data after dequeue)</span>
<span class="line">    Step4: Return the result.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cau-hoi-phong-van-cho-experienced" tabindex="-1"><a class="header-anchor" href="#cau-hoi-phong-van-cho-experienced"><span>Câu hỏi phỏng vấn cho Experienced</span></a></h2><h3 id="_16-hashmap-trong-java-la-gi" tabindex="-1"><a class="header-anchor" href="#_16-hashmap-trong-java-la-gi"><span>16. Hashmap trong Java là gì?</span></a></h3><p>HashMap trong Java là một bảng băm dựa trên việc thực hiện Java&#39;s Map interface. Map là một tập hợp các cặp key-value. Nó ánh xạ các key tới các value.</p><p>Nói đơn giản hơn thì HashMap về cơ bản chỉ định các unique key cho các value tương ứng có thể được truy xuất tại bất kỳ điểm nào.</p><h3 id="_17-yeu-cau-đoi-voi-mot-đoi-tuong-đuoc-su-dung-lam-khoa-hoac-gia-tri-trong-hashmap-la-gi" tabindex="-1"><a class="header-anchor" href="#_17-yeu-cau-đoi-voi-mot-đoi-tuong-đuoc-su-dung-lam-khoa-hoac-gia-tri-trong-hashmap-la-gi"><span>17. Yêu cầu đối với một đối tượng được sử dụng làm khóa hoặc giá trị trong HashMap là gì?</span></a></h3><p>Đối tượng khoá hay giá trị được dùng trong hashmap phải triển khai phương thức <code>equals()</code> và <code>hashcode()</code>.</p><p>Phương thức <code>hashcode()</code> được dùng khi thêm một đối tượng khoá vào map, còn <code>equals()</code> được dùng khi truy cập dữ liệu từ map.</p><h3 id="_18-xu-ly-xung-đot-trong-hashmap-voi-java" tabindex="-1"><a class="header-anchor" href="#_18-xu-ly-xung-đot-trong-hashmap-voi-java"><span>18. Xử lý xung đột trong HashMap với Java?</span></a></h3><p>Lớp <code>java.util.HashMap</code> trong Java sử dụng phương pháp chuỗi để xử lý xung đột. Trong chuỗi, nếu giá trị mới có khoá trùng với giá trị đã thêm vào, thì các giá trị này được lưu trữ trong danh sách liên kết ở bucket của khoá dưới dạng chuỗi cùng với giá trị hiện có.</p><p>Trong trường hợp tệ nhất, tất cả các khoá đều có cùng hashcode, nó sẽ trả về bảng băm giống như là một danh sách liên kết. Trong trường hợp này, việc tìm kiếm một giá trị sẽ mất độ phức tạp thời gian là O(n) thay vì O(1). Do đó, cần phải cẩn thận khi lựa chọn thuật toán băm.</p><h3 id="_19-đo-phuc-tap-thoi-gian-cua-thao-tac-get-va-put-trong-hashmap" tabindex="-1"><a class="header-anchor" href="#_19-đo-phuc-tap-thoi-gian-cua-thao-tac-get-va-put-trong-hashmap"><span>19. Độ phức tạp thời gian của thao tác get() và put() trong HashMap</span></a></h3><p>Độ phức tạp thời gian là O(1) giả sử rằng hàm băm được sử dụng trong hashmap phân phối các phần tử một cách đồng nhất giữa các bucket.</p><h3 id="_20-co-so-du-lieu-nao-đuoc-dung-cho-trien-khai-bo-đem-lru" tabindex="-1"><a class="header-anchor" href="#_20-co-so-du-lieu-nao-đuoc-dung-cho-trien-khai-bo-đem-lru"><span>20. Cơ sở dữ liệu nào được dùng cho triển khai bộ đệm LRU?</span></a></h3><p>Bộ đệm LRU (Least Recently Used) cho phép xác định nhanh một phần tử đã không được sử dụng trong thời gian dài, bằng cách sắp xếp các mục theo thứ tự sử dụng. Để thực hiện được điều này, hai cấu trúc dữ liệu được sử dụng:</p><ul><li><strong>Queue</strong> - Triển khai này sử dụng một danh sách liên kết đôi. Kích thước tối đa của hàng đợi dựa trên kích thước bộ đệm, bằng tổng số frame khả dụng. Các trang ít được dùng gần đây nhất sẽ ở gần với phần trước của hàng đợi trong khi các trang sử dụng nhiều gần đây nhất sẽ ở cuối hàng.</li><li><strong>Hashmap</strong> - Hashmap lưu trữ số trang dưới dạng khóa cùng với địa chỉ của nút hàng đợi tương ứng dưới dạng giá trị.</li></ul><p><img src="/assets/LRU-cache-4H78Pd_C.png" alt=""></p><h3 id="_21-hang-đoi-uu-tien-la-gi" tabindex="-1"><a class="header-anchor" href="#_21-hang-đoi-uu-tien-la-gi"><span>21. Hàng đợi ưu tiên là gì?</span></a></h3><p>Hàng đợi ưu tiên là một kiểu dữ liệu trừu tượng giống như một hàng đợi bình thường nhưng có quyền ưu tiên được gán cho các phần tử.</p><p>Các phần tử có mức độ ưu tiên cao hơn được xử lý trước các phần tử có mức độ ưu tiên thấp hơn.</p><p>Để thực hiện điều này, cần có tối thiểu hai hàng đợi - một hàng cho dữ liệu và hàng còn lại để lưu trữ mức độ ưu tiên.</p><h3 id="_22-co-the-luu-tru-mot-khoa-trung-lap-trong-hashmap-khong" tabindex="-1"><a class="header-anchor" href="#_22-co-the-luu-tru-mot-khoa-trung-lap-trong-hashmap-khong"><span>22. Có thể lưu trữ một khóa trùng lặp trong HashMap không?</span></a></h3><p><strong>Không</strong>, không thể chèn các khóa trùng lặp vào HashMap. Nếu bạn cố gắng chèn bất kỳ khoá nào bằng khóa hiện có, thì giá trị cũ sẽ bị ghi đè bằng giá trị mới. Và điều này sẽ không thay đổi kích thước của HashMap.</p><p>Đây là lý do tại sao phương thức <code>keySet()</code> trả về tất cả các khóa dưới dạng SET trong Java vì nó không cho phép trùng lặp.</p><h3 id="_23-cau-truc-du-lieu-cay-la-gi" tabindex="-1"><a class="header-anchor" href="#_23-cau-truc-du-lieu-cay-la-gi"><span>23. Cấu trúc dữ liệu cây là gì?</span></a></h3><p>Cây là một cấu trúc dữ liệu đệ quy, phi tuyến tính bao gồm tập hợp một hoặc nhiều nút dữ liệu trong đó một nút được chỉ định là gốc và các nút còn lại được gọi là con của gốc.</p><p>Cây tổ chức dữ liệu theo cách phân cấp.</p><p>Cấu trúc dữ liệu cây được sử dụng phổ biến nhất là cây nhị phân và các biến thể của nó.</p><p>Một vài ứng dụng của cây:</p><ol><li>Hệ thống file</li><li>Bình luận trên mạng xã hội</li><li>Cây gia phả</li></ol><p><img src="/assets/tree-data-structure-DHXu5Ho2.png" alt=""></p><h3 id="_24-cay-nhi-phan-la-gi" tabindex="-1"><a class="header-anchor" href="#_24-cay-nhi-phan-la-gi"><span>24. Cây nhị phân là gì?</span></a></h3><p>Cây nhị phân là một kiểu câu đặc biệt trong đó mỗi nút có nhiều nhất hai nút con. Cây nhị phân thường được phân chia thành ba tập con rời rạc, tức là gốc của cây, cây con bên trái và cây con bên phải.</p><p><img src="/assets/binary-search-tree-aNa3joAi.png" alt=""></p><h3 id="_25-so-luong-nut-toi-đa-cua-cay-nhi-phan-co-chieu-dai-k" tabindex="-1"><a class="header-anchor" href="#_25-so-luong-nut-toi-đa-cua-cay-nhi-phan-co-chieu-dai-k"><span>25. Số lượng nút tối đa của cây nhị phân có chiều dài k</span></a></h3><p>Số lượng nút tối đa là 2^(k+1) - 1, với k &gt;= 1.</p><h3 id="_26-viet-ham-đe-quy-tinh-chieu-cao-cay-nhi-phan-trong-java" tabindex="-1"><a class="header-anchor" href="#_26-viet-ham-đe-quy-tinh-chieu-cao-cay-nhi-phan-trong-java"><span>26. Viết hàm đệ quy tính chiều cao cây nhị phân trong Java</span></a></h3><p>Trước hết ta tạo một lớp đại diện cho mọi nút trong cây:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> data<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Node</span> left<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Node</span> right<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Hàm để tính chiều cao của cây:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">heightOfBinaryTree</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// If node is null then height is 0 for that node.</span></span>
<span class="line">        <span class="token keyword">else</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// compute the height of each subtree</span></span>
<span class="line">            <span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">heightOfBinaryTree</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">heightOfBinaryTree</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">//use the larger among the left and right height and plus 1 (for the root)</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span> rightHeight<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_27-viet-ham-java-đem-so-luong-nut-trong-cay" tabindex="-1"><a class="header-anchor" href="#_27-viet-ham-java-đem-so-luong-nut-trong-cay"><span>27. Viết hàm Java đếm số lượng nút trong cây</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> count <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">//Root itself should be counted</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">else</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        count <span class="token operator">+=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        count <span class="token operator">+=</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> count<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_28-duyet-cay-la-gi" tabindex="-1"><a class="header-anchor" href="#_28-duyet-cay-la-gi"><span>28. Duyệt cây là gì?</span></a></h3><p>Duyệt cây là quá trình đi qua tất cả nút trong cây. Từ gốc (root) là nút đầu tiên đến tất cả các nút được liên kết. Có 3 cách duyệt cây:</p><h4 id="_1-duyet-trung-thu-tu" tabindex="-1"><a class="header-anchor" href="#_1-duyet-trung-thu-tu"><span>1. Duyệt trung thứ tự:</span></a></h4><ul><li>Thuật toán: <ul><li>Bước 1: Duyệt cây con bên trái, gọi InOrder(root.left)</li><li>Bước 2: Duyệt root</li><li>Bước 3: Duyệt cây con bên phải, gọi InOrder(root.right)</li></ul></li><li>Code Java:</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// Print inorder traversal of given tree.</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">printInorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//first traverse to the left subtree</span></span>
<span class="line">    <span class="token function">printInorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//then print the data of node</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//then traverse to the right subtree</span></span>
<span class="line">    <span class="token function">printInorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Dùng: cho tìm kiếm kiếm cây nhị phân.</li></ul><h4 id="_2-duyet-tien-thu-tu" tabindex="-1"><a class="header-anchor" href="#_2-duyet-tien-thu-tu"><span>2. Duyệt tiền thứ tự:</span></a></h4><ul><li>Thuật toán: <ul><li>Bước 1: Duyệt root</li><li>Bước 2: Duyệt cây con bên trái, gọi InOrder(root.left)</li><li>Bước 3: Duyệt cây con bên phải, gọi InOrder(root.right)</li></ul></li><li>Code Java:</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// Print preorder traversal of given tree.</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">printPreorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">//first print the data of node</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//then traverse to the left subtree</span></span>
<span class="line">    <span class="token function">printPreorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//then traverse to the right subtree</span></span>
<span class="line">    <span class="token function">printPreorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Dùng: Để tạo bản sao cây, và cũng được sử dụng để lấy biểu thức tiền tố của cây biểu thức.</li></ul><h4 id="_3-duyet-hau-thu-tu" tabindex="-1"><a class="header-anchor" href="#_3-duyet-hau-thu-tu"><span>3. Duyệt hậu thứ tự:</span></a></h4><ul><li>Thuật toán: <ul><li>Bước 1: Duyệt cây con bên trái, gọi InOrder(root.left)</li><li>Bước 2: Duyệt cây con bên phải, gọi InOrder(root.right)</li><li>Bước 3: Duyệt root</li></ul></li><li>Code Java:</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// Print postorder traversal of given tree.</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">printPostorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//first traverse to the left subtree</span></span>
<span class="line">    <span class="token function">printPostorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//then traverse to the right subtree</span></span>
<span class="line">    <span class="token function">printPostorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">//then print the data of node</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Dùng: Dùng để xoá cây và cũng được sử dụng để lấy biểu thức hậu tố của cây biểu thức.</li></ul><p>Ví dụ: ta có cây nhị phân như sau:</p><p><img src="/assets/postorder-traversal-CBl2twAE.png" alt=""></p><ul><li>Duyệt trung thứ tự =&gt; Left, Root, Right : [4, 2, 5, 1, 3]</li><li>Duyệt tiền thứ tự =&gt; Root, Left, Right : [1, 2, 4, 5, 3]</li><li>Duyệt hậu thứ tự =&gt; Left, Right, Root : [4, 5, 2, 3, 1]</li></ul><h3 id="_29-cay-tim-kiem-nhi-phan-la-gi" tabindex="-1"><a class="header-anchor" href="#_29-cay-tim-kiem-nhi-phan-la-gi"><span>29. Cây tìm kiếm nhị phân là gì?</span></a></h3><p>Cây tìm kiếm nhị phân (BST) là một biến thể của cấu trúc dữ liệu cây nhị phân, lưu trữ dữ liệu một cách hiệu quả, trong đó các giá trị của các nút trong cây con bên trái nhỏ hơn giá trị của nút gốc và giá trị của các nút bên phải cao hơn nút gốc.</p><p>Ngoài ra, từng cây con bên trái và bên phải cũng phải đảm bảo tính chất trên trong mọi trường hợp.</p><p><img src="/assets/binary-search-tree-aNa3joAi.png" alt=""></p><h3 id="_30-cay-avl-la-gi" tabindex="-1"><a class="header-anchor" href="#_30-cay-avl-la-gi"><span>30. Cây AVL là gì?</span></a></h3><p>Cây AVL là cây cân bằng. Cây AVL kiểm tra chiều cao của cây con bên trái và bên phải và đảm bảo rằng sự khác biệt không quá 1. Sự khác biệt này được gọi là Hệ số Cân bằng và được tính bằng: <code>BalanceFactor = chiều cao (cây con bên trái) - chiều cao (cây con bên phải)</code>.</p><h3 id="_31-in-che-đo-xem-ben-trai-cua-bat-ky-cay-nhi-phan-nao" tabindex="-1"><a class="header-anchor" href="#_31-in-che-đo-xem-ben-trai-cua-bat-ky-cay-nhi-phan-nao"><span>31. In chế độ xem bên trái của bất kỳ cây nhị phân nào</span></a></h3><p>Ý tưởng chính để giải quyết vấn đề này là duyệt cây theo tiền thứ tự và truyền thông tin về cấp bậc cùng với nó. Nếu cấp được truy cập lần đầu tiên, thì chúng ta lưu trữ thông tin của nút hiện tại và cấp hiện tại trong hashmap. Về cơ bản, thì ta đang có được chế độ xem bên trái bằng cách quan sát đến nút đầu tiên của mọi cấp độ. Khi kết thúc quá trình duyệt, chúng ta có thể tìm ra giải pháp bằng cách duyệt qua map.</p><p>Hãy xem xét cây sau đây làm ví dụ để tìm chế độ xem bên trái:</p><p><img src="/assets/left-view-binary-tree-aTwH9gJM.png" alt=""></p><p>Code Java:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span></span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//to store a Binary Tree node</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Node</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> data<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Node</span> left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterviewBit</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// traverse nodes in pre-order way</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">leftViewUtil</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// if you are visiting the level for the first time</span></span>
<span class="line">        <span class="token comment">// insert the current node and level info to the map</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token function">leftViewUtil</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">leftViewUtil</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// to print left view of binary tree</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">leftView</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// create an empty HashMap to store first node of each level</span></span>
<span class="line">        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// traverse the tree and find out the first nodes of each level</span></span>
<span class="line">        <span class="token function">leftViewUtil</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// iterate through the HashMap and print the left view</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Node</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token function">leftView</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_32-cau-truc-du-lieu-đo-thi-la-gi" tabindex="-1"><a class="header-anchor" href="#_32-cau-truc-du-lieu-đo-thi-la-gi"><span>32. Cấu trúc dữ liệu đồ thị là gì?</span></a></h3><p>Đồ thị là một loại cấu trúc dữ liệu phi tuyến tính bao gồm các đỉnh hoặc nút được kết nối bằng các cạnh hoặc liên kết để lưu trữ dữ liệu. Đồ thị có thể là có hướng hoặc vô hướng.</p><p><img src="/assets/graph-data-structure-D25G2HLc.png" alt=""></p><h3 id="_33-ung-dung-cua-đo-thi" tabindex="-1"><a class="header-anchor" href="#_33-ung-dung-cua-đo-thi"><span>33. Ứng dụng của đồ thị?</span></a></h3><p>Đồ thị được sử dụng trong nhiều ứng dụng khác nhau. Một số trong số chúng như sau:</p><ul><li>Đồ thị mạng xã hội để xác định luồng thông tin trong các trang web mạng xã hội như facebook, linkedin, v.v.</li><li>Đồ thị mạng neural trong đó các nút đại diện cho các neuron và cạnh biểu thị các khớp thần kinh giữa chúng.</li><li>Lưới giao thông trong đó các trạm là các nút và các tuyến là các cạnh của đồ thị.</li><li>Đồ thị tiện ích điện hoặc nước trong đó các đỉnh là điểm kết nối và cạnh là dây hoặc đường ống kết nối chúng.</li><li>Thuật toán tìm đường đi ngắn nhất giữa hai điểm.</li></ul><h3 id="_34-lam-the-nao-đe-bieu-dien-đo-thi" tabindex="-1"><a class="header-anchor" href="#_34-lam-the-nao-đe-bieu-dien-đo-thi"><span>34. Làm thế nào để biểu diễn đồ thị?</span></a></h3><p>Ta có hai cách để biểu diễn đồ thị:</p><ul><li>Ma trận : Được sử dụng để biểu diễn dữ liệu tuần tự</li></ul><p><img src="/assets/adjacency-matrix-Dh4MN2D4.png" alt=""></p><ul><li>Danh sách: Sử dụng để biểu diễn dữ liệu được liên kết</li></ul><p><img src="/assets/adjacency-list-Cyk1T-dF.png" alt=""></p><h3 id="_35-su-khac-biet-giua-cau-truc-du-lieu-cay-va-đo-thi" tabindex="-1"><a class="header-anchor" href="#_35-su-khac-biet-giua-cau-truc-du-lieu-cay-va-đo-thi"><span>35. Sự khác biệt giữa cấu trúc dữ liệu cây và đồ thị</span></a></h3><p>Cây và đồ thị được phân biệt bởi cấu trúc cây phải được kết nối và không bao giờ có thể có vòng lặp (chu trình) trong khi trong đồ thị không có hạn chế đó.</p><p>Cây cung cấp thông tin chi tiết về mối quan hệ giữa các nút theo hệ thống phân cấp còn đồ thị tuân theo mô hình mạng.</p><h3 id="_36-su-khac-biet-giua-bfs-breadth-first-search-va-dfs-delth-first-search" tabindex="-1"><a class="header-anchor" href="#_36-su-khac-biet-giua-bfs-breadth-first-search-va-dfs-delth-first-search"><span>36. Sự khác biệt giữa BFS (Breadth First Search) và DFS (Delth First Search)</span></a></h3><table><thead><tr><th>BFS</th><th>DFS</th></tr></thead><tbody><tr><td>Breadth First Search</td><td>Depth First Search</td></tr><tr><td>Sử dụng hàng đợi</td><td>Sử dụng Ngăn xếp</td></tr><tr><td>Có thể được dùng để tìm đường đi ngắn nhất trong một đồ thị không trọng số, bởi vì trong BFS, ta có thể đến một đỉnh có số cạnh tối thiểu từ một đỉnh nguồn</td><td>Ta có thể đi qua nhiều cạnh hơn để đến một đỉnh đích từ một nguồn</td></tr><tr><td>Phù hợp để tìm kiếm các đỉnh gần với nguồn</td><td>Phù hợp khi có các giải pháp xa nguồn</td></tr><tr><td>Xem xét tất cả đỉnh lân cận do đó không thích hợp sử dụng trong trò chơi hay câu đố</td><td>Phù hợp cho vấn đề câu đố và trò chơi. Ta đưa ra quyết định sau đó khám phá tất cả đường đi thông qua quyết định này</td></tr><tr><td>Độ phức tạp thời gian O(V+E) khi dùng danh sách liền kề và O(V^2) khi dùng ma trận liền kề, trong đÓ V là đỉnh và E là cạnh</td><td>Độ phức tạp thời gian O(V+E) khi dùng danh sách liền kề và O(V^2) khi dùng ma trận liền kề, trong đÓ V là đỉnh và E là cạnh</td></tr><tr><td>Đến định liền kề trước khi đến đỉnh con</td><td>Đến đỉnh con trước khi đến đỉnh liền kề</td></tr></tbody></table><h3 id="_37-khi-nao-su-dung-dfs-tot-hon-bfs" tabindex="-1"><a class="header-anchor" href="#_37-khi-nao-su-dung-dfs-tot-hon-bfs"><span>37. Khi nào sử dụng DFS tốt hơn BFS?</span></a></h3><p>Việc sử dụng DFS hay BFS phụ thuộc nhiều vào cấu trúc của cây/đồ thị tìm kiếm, số lượng và vị trí của các giải pháp cần thiết:</p><ul><li>Nếu biết rằng giải pháp nằm gần gốc, thì BFS có thể tốt hơn.</li><li>Nếu cây rất sâu và hiếm giải pháp, DFS sẽ mất rất nhiều thời gian, và BFS có thể nhanh hơn.</li><li>Nếu cây rất rộng, BFS có thể cần quá nhiều bộ nhớ, vì vậy nó có thể hoàn toàn không thực tế. Ta DFS trong những trường hợp như vậy.</li><li>Nếu có nhiều giải pháp nhưng nằm sâu trong cây, nên chọn DFS.</li><li>Nếu cây rất sâu, ta sẽ cần hạn chế tìm kiếm với DFS.</li></ul><h3 id="_38-sap-xep-to-po-trong-đo-thi-la-gi" tabindex="-1"><a class="header-anchor" href="#_38-sap-xep-to-po-trong-đo-thi-la-gi"><span>38. Sắp xếp tô pô trong đồ thị là gì?</span></a></h3><ul><li><p>Sắp xếp tô pô của một đồ thị có hướng là một thứ tự sắp xếp của các đỉnh sao cho với mọi cung từ đỉnh <code>i</code> đến đỉnh <code>j</code> trong đồ thị, <code>i</code> luôn nằm trước <code>j</code>.</p></li><li><p>Sắp xếp tô pô chỉ khả dụng với Đồ thị có hướng không tuần hoàn (DAG).</p></li><li><p>Các ứng dụng:</p><ol><li>Lập kế hoạch công việc từ các phụ thuộc đã cho giữa các công việc.</li><li>Thứ tự đánh giá ô công thức trong bảng tính</li><li>Thứ tự các nhiệm vụ biên dịch được thực hiện trong tạo file,</li><li>Tuần tự hóa dữ liệu</li><li>Giải quyết sự phụ thuộc ký hiệu trong trình liên kết.</li></ol></li></ul><p>Code sắp xếp cấu trúc tô pô trong Java:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">    <span class="token comment">// V - total vertices</span></span>
<span class="line">    <span class="token comment">// visited - boolean array to keep track of visited nodes</span></span>
<span class="line">    <span class="token comment">// graph - adjacency list.</span></span>
<span class="line">    <span class="token comment">// Main Topological Sort Function.</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// Mark all the vertices as not visited</span></span>
<span class="line">        <span class="token keyword">boolean</span> visited<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">V</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">            visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token comment">// Call the util function starting from all vertices one by one</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">V</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span></span>
<span class="line">                <span class="token function">topologicalSortUtil</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// Print contents of stack -&gt; result of topological sort</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// A helper function used by topologicalSort</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">topologicalSortUtil</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">boolean</span> visited<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">                             <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// Mark the current node as visited.</span></span>
<span class="line">        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">Integer</span> i<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// Recur for all the vertices adjacent to the current vertex</span></span>
<span class="line">        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> graph<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            i <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">                <span class="token function">topologicalSortUtil</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// Push current vertex to stack that saves result</span></span>
<span class="line">        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_39-cho-mot-ban-đo-luoi-2d-m-x-n-trong-đo-gia-tri-1-đai-dien-cho-đat-va-0-đai-dien-cho-nuoc-tra-ve-so-luong-cac-hon-đao-đuoc-bao-quanh-boi-nuoc-va-đuoc-hinh-thanh-bang-cach-ket-noi-cac-vung-đat-lien-ke-theo-2-huong-theo-chieu-doc-hoac-chieu-ngang-gia-su-rang-cac-truong-hop-ranh-gioi-tuc-la-tat-ca-bon-canh-cua-luoi-đeu-đuoc-bao-quanh-boi-nuoc" tabindex="-1"><a class="header-anchor" href="#_39-cho-mot-ban-đo-luoi-2d-m-x-n-trong-đo-gia-tri-1-đai-dien-cho-đat-va-0-đai-dien-cho-nuoc-tra-ve-so-luong-cac-hon-đao-đuoc-bao-quanh-boi-nuoc-va-đuoc-hinh-thanh-bang-cach-ket-noi-cac-vung-đat-lien-ke-theo-2-huong-theo-chieu-doc-hoac-chieu-ngang-gia-su-rang-cac-truong-hop-ranh-gioi-tuc-la-tat-ca-bon-canh-cua-luoi-đeu-đuoc-bao-quanh-boi-nuoc"><span>39. Cho một bản đồ lưới 2D, m x n trong đó giá trị &quot;1&quot; đại diện cho đất và &quot;0&quot; đại diện cho nước, trả về số lượng các hòn đảo (được bao quanh bởi nước và được hình thành bằng cách kết nối các vùng đất liền kề theo 2 hướng - theo chiều dọc hoặc chiều ngang). Giả sử rằng các trường hợp ranh giới - tức là tất cả bốn cạnh của lưới đều được bao quanh bởi nước.</span></a></h3><p>Các hạn chế:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">m == grid.length</span>
<span class="line">n == grid[i].length</span>
<span class="line">1 &lt;= m, n &lt;= 300</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Giá trị của grid[i][j] có thể là <code>0</code> hoặc <code>1</code>.</p><p>Ví dụ:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">grid <span class="token operator">=</span> <span class="token punctuation">[</span></span>
<span class="line">  <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">[</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">[</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Output: 3</p><p>Code giải quyết trong Java:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">InterviewBit</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">||</span> grid<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">                    count<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token function">mergeIslands</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">return</span> count<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mergeIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span> m<span class="token operator">=</span>grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span> n<span class="token operator">=</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>i<span class="token operator">&gt;=</span>m<span class="token operator">||</span>j<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>j<span class="token operator">&gt;=</span>n<span class="token operator">||</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token char">&#39;1&#39;</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">&#39;X&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token function">mergeIslands</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">mergeIslands</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">mergeIslands</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">mergeIslands</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_40-cau-truc-du-lieu-heap-la-gi" tabindex="-1"><a class="header-anchor" href="#_40-cau-truc-du-lieu-heap-la-gi"><span>40. Cấu trúc dữ liệu heap là gì?</span></a></h3><p>Heap là một cấu trúc dữ liệu phi tuyến tính dựa trên một cây nhị phân hoàn chỉnh. Một cây nhị phân được cho là hoàn chỉnh nếu tất cả các cấp được lấp đầy hoàn toàn ngoại trừ cấp cuối cùng và cấp cuối cùng có tất cả các phần tử hướng về bên trái càng nhiều càng tốt. Các heap có hai loại:</p><ol><li>Max-Heap:</li></ol><ul><li>Trong một Max-Heap, phần tử dữ liệu hiện diện ở nút gốc phải lớn nhất trong số tất cả các phần tử dữ liệu có trong cây.</li><li>Thuộc tính này phải đúng một cách đệ quy cho tất cả các cây con của cây nhị phân đó.</li></ul><ol start="2"><li>Min-Heap:</li></ol><ul><li>Trong một Min-Heap, phần tử dữ liệu hiện diện ở nút gốc phải là nhỏ nhất trong số tất cả các phần tử dữ liệu có trong cây.</li><li>Thuộc tính này phải đúng một cách đệ quy cho tất cả các cây con của cây nhị phân đó</li></ul></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><!----><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-DFqNa0KN.js" defer></script>
  </body>
</html>
